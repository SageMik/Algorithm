# 深度优先搜索（Depth-First-Search）

## 图的寻路问题

<table style="text-align: center;">
	<tr>
		<td><img src=".pic\DFS_1.1_FindingRoads.png" style="zoom: 50%" /></td> 
		<td><img src=".pic\DFS_1.2_FindRoadsProcess.png" style="zoom: 50%" /></td>
	</tr>
</table>

**给定一个图（左图），如何通过编程寻找从1到8的所有路径？**

我们提出这样一种策略：从1开始行走，选择1所连通的点继续行走，若无路可走，则回退到上一个点并选择其它未走过的点行走，如此反复，直到行走到终点8为止。

用流程图（右图）来表示就是：

+ 一开始，程序选择了 1->2->3->4 的路径，此时发现已经无路可走，便从 4 回退到 3 ，发现 5 未曾走过，于是选择了 5->6->7->8 的路径，完成目标。
+ 由于走到了 8 已经无路可走，且该路径上所有的点已经走过，于是清除路径上的所有标记，并直接回退到 1，选择 3->2 的路径，然后从 2 回退到 3 ，选择 4 后再回退到 3，最终选择 5->6->7->8 ，完成目标。
+ 至此，所有路径就被探索出来了。

这种策略，便是我们所说的**深度优先搜索（Depth-First-Search）**。

## 深度优先搜索

基于上文的流程图，我们发现如下特征：

1. 为了避免走到已经走过的点导致死循环（如从 1 走到 2 ，又从 2 走回 1，如此反复），需要进行**标记**。
2. 这种策略本质上是一种枚举，但又并非是简单的枚举，而是**一种会产生多条枚举分支的枚举**（如从 1 开始，产生 2->3->…… 和 3->…… 的分支）。这样的枚举需要**循环递归**才足以应对。
3. 行走的过程中，我们需要记录下路径上的点，而基于第2点，若使用局部变量，每次递归都会产生新的局部变量，会导致内存占用过大。因此我们可以使用**全局变量**记录所需内容。当其中一条枚举分支完成目标，我们便将其输出（或记录到其他地方），以腾出全局变量让其它枚举分支使用，这样一来，尽管所有枚举分支共用同样的全局变量，它们直接却不会互相影响。

由此，我们便引出 **深度优先搜索（Depth-First-Search, DFS, 深搜）** 的概念：**从未被标记的节点开始，产生可能的枚举分支，并沿这样的枚举分支深入，继续产生分支，直到所有的节点都被标记或完成目标。**

## 深搜基本模板

深搜的基本要素：**循环递归，标记，全局变量**。

+ **循环递归：** 以产生新的搜索分支。
+ **标记：** 避免走重复路以至于进入死循环。
+ **全局变量：** 对应场景需求，如记录深度，所走路径等。

```c++
Dfs(V) {
	如果 (V是旧点) {
        //此处可能依场景需求需要一定操作，如输出结果等
		return;
	}
	将V标记为旧点;
	对 (和V相邻的每个点U) {
		Dfs(U);
	}
}

int main() {
    将所有点都标记为新点;
    当 (在图中能找到新点V) {
	    Dfs(V);
	}
}
```

## 图的表示方法

### 一、邻接矩阵

对于一幅含有n个节点的图，可以用一个**二维数组**G来存放，其中 G \[ V \] \[ U \] 表示节点V和节点U之间边的情况（如是否有边，边方向，权值大小等) ，这个二维数组就是**邻接矩阵**，其遍历复杂度为 **O(n<sup>2</sup>)**。

### 二、邻接表

对于图的每一个节点V，可以用一个**一维数组**存放，一维数组里包含与V连通的边的信息，包括边的另一个节点，边的权值等。所有节点的一维数组就构成了**邻接表**，其遍历复杂度为  **O(n+e) ** ，n为节点数目，e为边数目。如下图，其邻接表可以表示为：

<table style="text-align: center;">
	<tr>
		<td><img src=".pic\DFS_1.1_FindingRoads.png" style="zoom: 50%" /></td> 
		<td><img src=".pic\DFS_4.1_AdjacentList.png" style="zoom: 50%" /></td>
	</tr>
</table>

## 例题

### 一、城堡问题（OJ1435）

#### 题目描述

下图是一个城堡的地形图。 请你编写一个程序，计算城堡一共有多少房间， 最大的房间有多大。城堡 被分割成 m×n (m≤50 ，n≤50) 个方块，每个方块可以有 0~4 面墙。 

```
     1   2   3   4   5   6   7  
   #############################
 1 #   |   #   |   #   |   |   #
   #####---#####---#---#####---#
 2 #   #   |   #   #   #   #   #
   #---#####---#####---#####---#
 3 #   |   |   #   #   #   #   #
   #---#########---#####---#---#
 4 #   #   |   |   |   |   #   #
   #############################
   
   #  = Wall   
   |  = No wall
   -  = No wall
```

##### 输入

程序从标准输入设备读入数据。 
第一行是两个整数，分别是南北向、东西向的方块数。 
在接下来的输入行里，每个方块用一个数字（0≤p≤50）描述。用一个数字表示方块周围的墙，1 表示西墙，2 表示北墙，4 表示东墙，8 表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块 (1,1)的南墙同时也是 方块(2,1) 的北墙。 
输入的数据保证城堡至少有两个房间。

##### 输出

城堡的房间数、城堡中最大房间所包括的方块数。每行1个数。
结果显示在标准输出设备上。

##### 样例输入

```
4
7
11 6 11 6 3 10 6
7 9 6 13 5 15 5
1 10 12 7 13 7 5
13 11 10 8 10 12 13

```

##### 样例输出

```
5
9
```

#### 解题思路

##### 1. 枚举 -> 深搜

对于此类会**产生多个枚举分支的枚举**，循环无法解决，需要使用**循环递归**。

1. 方块需要**标记**，以避免重复枚举而陷入死循环（详见第4步）。
2. 寻找**未标记**的方块，以这样的方块为起点启动枚举 **（最外层循环条件）** 。
3. 对四个方向进行枚举：有墙则换一个方向，没墙则移动到该方向的方块上 **（递归调用条件）** 。
4. 若当前方块已被标记，则终止当前搜索 **（递归边界条件）** ，因为 **将当前方块设为A，产生对A的搜索的方块设为B，则对B的搜索正是由A产生的，不存在其它可能，换句话说，A搜索了B，B又搜索回了A** 。在没有标记的情况下，这里便会陷入死循环。因此，方块的标记是确有必要的。
5. 若当前方块未被标记，则重复第3步。

这就符合了深搜的基本要素，利用深搜的思想解决问题：**以深度优先，不断递归产生新的搜索分支进行搜索**。

有了这样的思路，问题也就迎刃而解了：

- 城堡的房间数——**最外层循环每启动一次枚举，表明开始对新的房间进行搜索，房间数 + 1**。
- 城堡的最大房间——**每移动到未标记的方块上，当前房间的方块数 + 1**；**最外层循环的枚举结束后**，表明对当前房间的搜索已经结束，故**在已记录的最大房间方块数和当前房间方块数之间取最大值**即可。

##### 2. 城堡 -> 图

更进一步的，我们可以将**具体问题抽象化**，则可以以图的思想看待这个问题。

- 城堡的房间数——**极大连通子图**的个数。

- 城堡的最大房间——**极大连通子图**中的节点数最多的图的节点数。

> **极大连通子图：** 从图中取出若干个连通的点组成的图，称为连通子图；若往连通子图中加入任何一个点都会使该连通子图不再连通，则称其极大连通子图。

##### 3. 用一个数字表示多种状态组合

> 用一个数字表示方块周围的墙，1 表示西墙，2 表示北墙，4 表示东墙，8 表示南墙。

方块周围四个方向的墙可视为四个状态。四个状态的值只有 有 和 无，故其组合有 2<sup>4</sup> = 16 (种)。

为了方便记录，用一个数字来表示多种状态的组合是可行的，但要自己制定数字与组合的对应是比较麻烦的（比如用1表示只有西墙，2表示只有西墙和北墙，……），因此题目中的技巧值得我们借鉴。

题目各用一个数字来表示这四个状态，方块四个方向的墙的有无便可以用对应数字相加得到的数来表示。原因在于**这四个数字都是2的N次方，正好对应着二进制中的四位——相加得到的数与四个数字分别进行与的位运算，即可得到对应的墙的有无。** 

> 西墙：(1)<sub>10</sub> = (0001)<sub>2</sub>
> 北墙：(2)<sub>10</sub> = (0010)<sub>2</sub>
> 东墙：(4)<sub>10</sub> = (0100)<sub>2</sub>
> 南墙：(8)<sub>10</sub> = (1000)<sub>2</sub>

例如 (13)<sub>10</sub> = (1101)<sub>2</sub>，

> 13 & 1 = 1，表明有西墙
> 13 & 2 = 0，表明无北墙
> 13 & 4 = 4，表明有东墙
> 13 & 8 = 8，表明有南墙

利用该技巧，可以用一个数字表示多种状态的组合。

#### 代码实现

```c++
#include <iostream>
#include <cstring> // memset() 所需头文件
using namespace std;

#define W 1 //西 
#define N 2 //北 
#define E 4 //东 
#define S 8 //南 

int R, C;
int block[50][50];
int visited[50][50];
int roomNum = 0; //房间数量
int maxRoom = 0; //目前最大房间方块数
int preRoom; //当前房间方块数

void Dfs(int i, int j) {
	if(visited[i][j]) //移动到了标记过的方块，直接结束本次搜索
		return;
	preRoom++; //当前房间方块数 + 1
	visited[i][j] = 1; //标记
	if((block[i][j] & W) == 0) Dfs(i, j - 1); //西
	if((block[i][j] & N) == 0) Dfs(i - 1, j); //北
	if((block[i][j] & E) == 0) Dfs(i, j + 1); //东
	if((block[i][j] & S) == 0) Dfs(i + 1, j); //南
    //数据保证了城堡的周围都是墙，不用担心出现 (i < 0 || j < 0) 的情况
}

int main() {
    //依题意输入数据
	cin >> R >> C;
	for(int i = 0; i < R; i++)
		for(int j = 0; j < C; j++)
			cin >> block[i][j];

    memset(visited, 0, sizeof(visited)); //所有标记清零，表示所有方块未访问
	for(int i = 0; i < R; i++) //遍历
		for(int j = 0; j < C; j++)
			if(!visited[i][j]) { //未标记的方块
				roomNum++; //表明是新房间
				preRoom = 0; //清除上一个房间的方块数，开始计算当前房间方块数
				Dfs(i, j);
				maxRoom = max(preRoom, maxRoom); //取最大房间的方块数
			}
    
	cout << roomNum << endl << maxRoom << endl;
    return 0;
}
```

### 二、N皇后问题（OJ1406）

#### 题目描述

在N*N的棋盘上放置N个皇后（n<=10）而彼此不受攻击（即在棋盘的任一行，任一列和任一对角线上不能放置2个皇后），编程求解所有的摆放方法。

##### 输入

  输入n

##### 输出

每行输出一种方案，每种方案顺序输出皇后所在的列号，每个数占5列（输出时按字典序）。
若无方案，则输出no solute!

##### 样例输入

```
 4
```

##### 样例输出

```
    2    4    1    3
    3    1    4    2
```

#### 代码实现

```c++
#include<iostream>
#include<iomanip> // cout setw() 所需头文件
#include<cmath>
using namespace std;

#define MAXN 10
int queen[MAXN]; //记录每个皇后的列号，即皇后的摆放方法
int n;
int flag; //用于判断当前皇后的摆放方式是否合法
int sum; //记录摆放方法的个数，以便判断是否问题是否有解
void Dfs(int k) {
	if(k == n) { //摆放完毕，输出
		sum++;
		for(int i = 0; i < n; i++)
			cout<<setw(5)<<queen[i] + 1;
		cout<<endl;
		return;
	}
	
	flag = 1;
	for(int col = 0; col < n; col++) {
		for(int row = 0; row < k; row++) { //对已摆放的皇后进行遍历
			if(col == queen[row] || abs(k - row) == abs(col - queen[row])) {
                //在同一列或在对角线上，则摆放不符合题意
				flag = 0;
				break;
			}
		}
		
		if(flag) { //当前
			queen[k] = col; 
			Dfs(k + 1);  //继续摆放下一个皇后
		}
		
		flag = 1; //回溯，消除影响
	}
}

int main() {
	cin>>n;
	sum = 0; 
	Dfs(0);
	if(!sum) 
		cout<<"no solute!"<<endl;
	return 0;
} 
```

